subvector

Вам нужно написать набор функций, который будет реализовывать расширяемый массив. Назовем его subvector, потому что он очень похож на vector из STL, и основан на той же идее. 

В этом семестре с классами мы еще не работаем, поэтому subvector будет выглядеть как структура и набор функций. 
struct subvector {
     int *mas;
     unsigned int top; 
     unsigned int capacity;
};
Структура представляет собой комплект из:
- указателя на массив в куче (mas), 
- размер той памяти, с которой мы работаем, в которой есть осмысленные данные (top), 
- размер памяти, выделенной в этой куче (capacity).

Полный список функций, который вам нужно реализовать:
bool init(subvector *qv); //инициализация пустого недовектора (top и capacity по нулям, а mas это NULL)
bool push_back(subvector *qv, int d); //добавление элемента в конец недовектора с выделением дополнительной памяти при необходимости
int pop_back(subvector *qv); //удаление элемента с конца недовектора, значение удаленного элемента вернуть
bool resize(subvector *qv, unsigned int new_capacity); //увеличить емкость недовектора (можно использовать и для уменьшения - тогда, в рамках данной реализации, если top меньше новой capacity, то копируем только то, что влезает, и уменьшаем top до capacity)
void shrink_to_fit(subvector *qv); //очистить неиспользуемую память
void clear(subvector *qv); //очистить содержимое недовектора, занимаемое место при этом не меняется
void destructor(subvector *qv);	//очистить всю используемую память, инициализировать недовектор как пустой

При работе с такой структурой мы можем выделить себе сколько-то места заранее, а можем расширять место по мере необходимости. 
Наш subvector'а работает по принципу стека, и у него два размера. Capacity - это общий объем выделенной памяти, которой можно брать с запасом. Top - размер занятой памяти, осмысленных данных. Top не может быть больше capacity, чтобы мы не выехали за "свои" данные. При удалении элемента уменьшается top, но не capacity. При добавлении элемента top увеличивается, если при этом он становится больше capacity, то перед добавлением элемента нужно вызвать resize.

Вам нужно реализовать все эти функции и вписаться в профайлер - программу, которая проверяет корректность работы вашей программы. Это значит, что все методы должны быть реализованы, у них должны быть правильные интерфейсы (то есть заголовки - тип возвращаемого значения, название, список аргументов), они не должны терять данные и память. 

Профайлер лежит в соседнем файле с говорящим названием subvector_profiler.cpp. Он умеет подключать ваш код через include - если вы сохраните свой код с названием subvector.cpp, положите этот файл рядом с профайлером и не забудете удалить свой main (оставив только структуру и функции), то можете компилировать этот профайлер, и он просто приклеит вашу реализацию сабвектора (так и работатет include).

Проверку на утечки памяти можно проводить с помощью valgrind (видеоинструкция, как его ставить и как им пользоваться, тут https://youtu.be/LE7yZZn04Pc?list=PLecy9mZ2ycLIGinAju5IiVpN_aTj1Ratc). 

Это не контест, поэтому за какой-то дополнительный вывод на экран (например, предупреждение или информация от отладки) штрафов не будет. Только постарайтесь, чтобы его было не очень много, и он не заспамил полезный вывод.